{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainHomeComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "1424caa3-2102-49dc-abf6-6aef966076f2",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            notes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded MainHomeComponent');\n            \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          await this.fetchExternal();\n          this.fetchMine();\n        }\n        \n        @autobind\n        fetchExternal(){\n          \n          return new Promise(async (resolve,reject)=>{\n              \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main' // should keep using for browser development! \n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            this.setState({\n              ExternalIdentityNode\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchMine(){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingMine: true\n              })\n              \n              // Get my identity \n              // - should use \"signer\" instead? \n              // - or just look for ones where signer=author \n              let author = this.state.ExternalIdentityNode.data.identity; // \"idtest:nick\"\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // Part 1/3\n                          // Fetch MY threads (where I am the author) \n                          // - of a \"post:Qmfdlsj\" type \n                          // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                          {\n                            matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                            dataForAction: {\n                              // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              type: 'shared_data_request:Qmsdfljsdj',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Part 1/2\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      // // not root level\n                                      // if(inputNode.nodeId){\n                                      //   return false;\n                                      // }\n                                      \n                                      \n                                      \n                                      if(inputNode.data.signer != \"${author}\"){\n                                        return false;\n                                      }\n                                      // type:\"post:..\".data = {message, author, in_reply_to, thread_ref}\n                                      if(inputNode.data.data.author != \"${author}\"){\n                                        return false;\n                                      }\n                                      \n                                      \n                                      \n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      // TODO: return only inputNode.data.data.thread_ref\n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          },\n                          \n                          // Part 2/3 \n                          // - reduce above (from requestCache) to thread_ref, and use in next step! \n                          {\n                            matchActionType: 'reduce_search:Qmlfjsdlsf',\n                            dataForAction: {\n                              // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              type: 'reduce_request:Qmsf89h923sf',\n                              data: {\n                              \n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    return new Promise(async (resolve,reject)=>{\n                                      // Part 2/3\n                                      // Reduce for next step \n                                      // - setting requestVariables too \n                                      \n                                      let requestCache = INPUT.data.requestCache; \n                                      // await universe.getRequestCache();\n                                      \n                                      let lastRequestResults;\n                                      try {\n                                        lastRequestResults = requestCache.keyvalue.request0; // 1st/2nd request (depending on authtoken)\n                                      }catch(err){\n                                        console.error(err);\n                                      }\n                                      \n                                      lastRequestResults = lastRequestResults || [];\n                                      \n                                      let threadRefs = lastRequestResults.map(req=>{\n                                        return req.data.data.thread_ref;\n                                      });\n                                      \n                                      // console.log('lastRequestResults:', JSON.stringify(lastRequestResults, null, 2));\n                                      \n                                      // let inputNode = INPUT.data.inputNode;\n                                      \n                                      // return inputNode;\n                                      return resolve({\n                                        type: 'array_of_refs:Qmdslfjsdlf22',\n                                        data: {\n                                          refs: threadRefs\n                                        }\n                                      });\n                                      \n                                    });\n                                  })()`\n                                }\n                              },\n                              \n                            }\n                          },\n                          \n                          \n                          // Part 3/3\n                          // Fetch data for thread_refs (includes My results too) \n                          // - of a \"post:Qmfdlsj\" type \n                          // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                          {\n                            matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                            dataForAction: {\n                              // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              type: 'shared_data_request:Qmsdfljsdj',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Part 3/3\n                                      \n                                      // return all results that match thread_ref! \n                                      // - me, plus anyone else! \n                                      \n                                      console.log('PART 3/3');\n                                      \n                                      let requestCache = INPUT.data.requestCache; \n                                      \n                                      let threadRefResultNode;\n                                      try {\n                                        threadRefResultNode = requestCache.keyvalue.request1; // 2nd/3rd request (depending on authtoken)\n                                      }catch(err){\n                                        console.error(err);\n                                      }\n                                      \n                                      console.log('threadRefResultNode',threadRefResultNode);\n                                      \n                                      let threadRefs = threadRefResultNode.data.refs;\n                                      \n                                      // lastRequestResults = lastRequestResults || [];\n                                      \n                                      // let threadRefs = lastRequestResults.map(req=>{\n                                      //   return req.data.data.thread_ref;\n                                      // });\n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      // request should have the values I expect to use? \n                                      // - or they should be part of the input, if \"piping\" from one to next? \n                                      //   - lots of ways to do this... \n                                      \n                                      if(threadRefs.indexOf(inputNode.data.data.thread_ref) === -1){\n                                        return false;\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          },\n                          \n                          // TODO: clear results I dont care about (map->reduce...kill all the map results!) \n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[2].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                notes: nodes,\n                fetchingMine: false\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingMine: false\n              })\n              \n            }\n            \n          });\n          \n          \n        }\n        \n        @autobind\n        async addPost(){\n          \n          let text = WINDOW.prompt('', 'test text ' + (new Date()).getTime());\n          if(!text){\n            return false;\n          }\n          \n          console.log('State:', this.state);\n          \n          let sharedNode = {\n            type: 'post:Qmskldfjf',\n            data: {\n              in_reply_to: null,\n              thread_ref: universe.uuidv4(),\n              message: text,\n              author: this.state.ExternalIdentityNode.data.identity, // \"idtest:nick\"\n              createdAt: Date.now(), // utc milliseconds since epoch \n              // TODO: verified/signed timestamp for this message (3rd party) \n            }\n          }\n          \n          // should be OK to contain a code template \n          let permissionsNode = {};\n          \n          let syndicateToNode = {};\n          \n          let saveSharedNode = await this.createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode);\n          \n          console.log('saveSharedNode',saveSharedNode);\n          \n          \n        }\n        \n        @autobind\n        createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', sharedNode);\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.state.ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // TODO: use identity token \n                          {\n                            matchActionType: 'create_and_syndicate:Qmwlekjfwl',\n                            dataForAction: {\n                              type: 'create_and_syndicate_data:Qmskfjwoesjf',\n                              data: {\n                                sharedNode, // should include author=Second \n                                permissionsNode, // who can access this, get syndicated also \n                                syndicateToNode // where to syndicate this sharedNode  \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_and_syndicate response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        render(){\n          \n          return (\n            <div className=\"container\">\n              <div className=\"columns\">\n                <div className=\"column is-3\">\n                \n                  <br />\n                  \n                  <h2>\n                    <button className=\"button is-info\" onClick={this.addPost}>\n                      + Post\n                    </button>\n                    <hr />\n                    {\n                      !this.state.fetchingMine ? \n                      <button className=\"button\" onClick={this.fetchMine}>\n                        Fetch New\n                      </button>:\n                      <button className=\"button is-loading2\" onClick={this.fetchMine}>\n                        loading\n                      </button>\n                    }\n                  </h2>\n                  \n                  <br />\n                  \n                  <div>\n                    {\n                      this.state.notes.map((note,idx)=>(\n                        <div key={note._id} style={{paddingBottom:\"8px\"}}>\n                          <div className=\"box\" onClick={e=>this.handleUpdateNote(idx)} style={{position:'relative'}}>\n                            <span className=\"delete\" style={styles.deleteIcon} onClick={e=>this.handleRemoveNote(e, idx)}></span>\n                            {\n                              note.data.data.message\n                            }\n                            <br />\n                            - {\n                              note.data.data.author.split(':').slice(1).join(':')\n                            }\n                          </div>\n                        </div>\n                      ))\n                    }\n                  </div>\n                  \n                </div>\n                \n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainHomeComponent"
  }
}