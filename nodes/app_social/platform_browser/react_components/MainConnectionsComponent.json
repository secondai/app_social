{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainConnectionsComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "3bbb860a-423e-4670-8beb-8db80027de87",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            groups: [],\n            groupConnections: [],\n            allExternalConnections: [],\n            identityNodeIdsToGroups: {} // will end up being an obj: {identity._id => groupNode}\n          }\n        }\n        \n        componentDidMount(){\n            \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          await this.fetchAll();\n        }\n        \n        @autobind\n        async fetchAll(){\n          await this.fetchGroups();\n          await this.fetchExternalConnections();\n        }\n        \n        @autobind\n        fetchGroups(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingGroups: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              groups: nodes,\n              fetchingGroups: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchExternalConnections(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingConnections: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'external_identity'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            console.log('fetchExternalConnections Response:', response);\n            \n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              allExternalConnections: nodes,\n              fetchingConnections: false\n            }, this.updateConnectionGroups);\n            \n            resolve(nodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        updateConnectionGroups(){\n          \n          // Updates all connections with correct groups \n          // - probably should cache this? \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let identityNodeIdsToGroups = {};\n            \n            for(let externalIdentity of this.state.allExternalConnections){\n              \n              // console.log('User:', externalIdentity);\n              identityNodeIdsToGroups[externalIdentity._id] = [];\n              \n              let externalParsed = (externalIdentity.data.identity || ':').split(':');\n              let idType = externalParsed[0];\n              let username = externalParsed[1];\n              let subname;\n              let usernameSplit = username.split('@');\n              if(usernameSplit.length > 1){\n                subname = usernameSplit[0];\n                username = usernameSplit[1];\n              }\n              \n              console.log('UserParsed:', idType, subname, '@', username);\n              \n              // Evaluate against Group conditions \n              // - order matters! \n              \n              for(let groupNode of this.state.groups){\n                \n                let allow = false;\n              \n                for(let filter of groupNode.data.identities){\n                  \n                  console.log('identityFilter:', filter);\n                  \n                  switch(filter.type.split(':')[0]){\n                    case 'identity_range': // implied: \"allow\"\n                      // Check matching \n                      if(filter.data.idType == idType){\n                        if(filter.data.username == '*' || filter.data.username == username){\n                          if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                            allow = true;\n                          }\n                        }\n                      }\n                      break;\n                    \n                    case 'identity_range_deny': \n                      // Check matching \n                      if(filter.data.idType == idType){\n                        if(filter.data.username == '*' || filter.data.username == username){\n                          if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                            allow = false;\n                          }\n                        }\n                      }\n                      break;\n                      \n                    default:\n                      console.error('Invalid identity_range type for matching!');\n                      break;\n                  }\n                  \n                }\n                \n                if(allow){\n                  identityNodeIdsToGroups[ externalIdentity._id ].push(groupNode);\n                }\n              }\n              \n            }\n            \n            this.setState({\n              identityNodeIdsToGroups\n            });\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        handleViewConnection(externalIdentityNode){\n          this.setState({\n            externalIdentityNode\n          },this.updateConnectionGroups);\n        }\n        \n        @autobind\n        handleAddToGroup(groupNode){\n          \n          // Add an individual identity to a group \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // Get type of restriction for group \n            // - who to allow/deny for inclusion \n            //   - matched identities or provided info (token provided) \n            \n            let matchType;\n            // let matchType = WINDOW.prompt('match type (identity_range):','identity_range');\n            // if(!matchType){\n            //   return false;\n            // }\n            \n            let idType = WINDOW.prompt('idType (id, idtest, * for anything):','*');\n            if(typeof idType != 'string'){\n              return false\n            }\n            let username = WINDOW.prompt('username (* for anything, subname@username):','*');\n            if(typeof username != 'string'){\n              return false\n            }\n            \n            let subname = ''; // empty is for root \n            let usernameSplit = username.split('@');\n            if(usernameSplit.length > 1){\n              subname = usernameSplit[0];\n              username = usernameSplit[1];\n            }\n            \n            if(username == '*'){\n              subname = '*';\n            }\n            \n            matchType = \"identity_range:Qmsfljlkjs329f\";\n            if(includeOrExclude == 'exclude'){\n              matchType = \"identity_range_deny:Qmsdfj9823jf923f\";\n            }\n            \n            // only \"identity_range\" types for now \n            let matchNode = {\n              type: matchType, \n              data: {\n                idType,\n                username,\n                subname\n              }\n            }\n            \n            groupNode.data.identities.push(matchNode);\n            \n            console.log('Updating groupNode:', groupNode);\n            \n            \n            let updatedNode = await this.makeSaveRequest(groupNode);\n            \n            await this.fetchGroups();\n            \n          });\n            \n        }\n        \n        @autobind\n        async handleAddConnection(){\n          let networkAndUsername = WINDOW.prompt('network:username (idtest:test1)','idtest:');\n          if(!networkAndUsername){\n            return false;\n          }\n          let networkAndUsernameSplit = networkAndUsername.split(':');\n          if(networkAndUsernameSplit.length != 2){\n            WINDOW.alert('Invalid input');\n            return false;\n          }\n          let network = networkAndUsernameSplit[0].trim();\n          let username = networkAndUsernameSplit[1].trim();\n          \n          let opts = {};\n          switch(network){\n            case 'id':\n              opts = {\n                address: 'https://horizon.stellar.org',\n                network: 'public',\n              }\n              break;\n            case 'idtest':\n              opts = {\n                address: 'https://horizon-testnet.stellar.org',\n                network: 'test',\n              }\n              break;\n            default:\n              console.error('Invalid network type, expecting id or idtest');\n              return false;\n          }\n          \n          this.setState({\n            addingConnection: true\n          });\n          \n          let Friend_ExternalIdentityNode = await universe.getSecondForUsername(username,opts);\n          \n          // Update to include identity (in case not included by remote) \n          Friend_ExternalIdentityNode.data.identity = networkAndUsername;\n          \n          // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // // - uses a constant value (token) from the remote Second! \n          // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'getAddressForWords',\n          //     options: {\n          //       words\n          //     }\n          //   }\n          // });\n          \n          // let address = addressNode.data;\n          \n          // console.log('Address:', address);\n          \n          // let Friend_ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('MySecond:', this.props.state.OwnerSecondExternalIdentityNode);\n          console.log('FriendSecond', Friend_ExternalIdentityNode);\n          \n          \n          // Make TalkToSecond request to Identify MySecond with remote \n          let connectionResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                      {\n                        matchActionType: 'identify_challenge_initiate:0.0.1:local:8239hf28hf283h',\n                        dataForAction: {\n                          type: 'challenge_init_remote:0.0.1:...',\n                          data: {\n                            ExternalIdentityNode: Friend_ExternalIdentityNode\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('Friend Connection Response:', connectionResponse);\n          \n          let responseNode = connectionResponse.data.actionResponses[0];\n          \n          this.setState({\n            addingConnection: false\n          });\n          \n          // if added, include an internal \"basic data\" node \n          // - tags? \n          if(responseNode.data.result){\n            \n            let newExternalMetadata = {\n              nodeId: responseNode.data.node._id,\n              type: 'external_metadata:dslfjdklj',\n              data: {\n                identity: networkAndUsername,\n                tags: []\n              }\n            }\n            console.log('newExternalMetadata', newExternalMetadata);\n            let savedNode = await this.forceNewNode(newExternalMetadata, {skipExistingLearnedNodeId: true});\n            \n          } else {\n            WINDOW.alert('Failed Adding Connection');\n          }\n          \n          \n          await this.fetchExternalConnections();\n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        renderConnections(){\n          let identityNodeIdsToGroups = this.state.identityNodeIdsToGroups;\n          return this.state.allExternalConnections.filter(externalIdentityNode=>{\n            // require the identity to exist\n            return externalIdentityNode.data.identity;\n          }).map(externalIdentityNode=>{\n            return (\n              <div key={externalIdentityNode._id}>\n              \n                <h3 className=\"title is-5\" onClick={e=>this.handleViewConnection(externalIdentityNode)}>\n                  {externalIdentityNode.data.identity}\n                </h3>\n                \n                <div>\n                  {\n                    !(identityNodeIdsToGroups[externalIdentityNode._id] || []).length ? '':\n                    \n                    <div className=\"tags\">\n                      {\n                        (identityNodeIdsToGroups[externalIdentityNode._id] || []).map(groupNode=>(\n                          <span key={groupNode._id} className=\"tag is-light\">{groupNode.data.name}</span>\n                        ))\n                      }\n                    </div>\n                  }\n                                \n                </div>\n                \n                <br />\n                \n              </div>\n            )\n          });\n        }\n        \n        @autobind\n        renderConnection(){\n          // Render info for the selected group \n            \n          if(!this.state.externalIdentityNode){\n            return '';\n          }\n          \n          let externalIdentityNode = this.state.externalIdentityNode;\n          \n          let identityNodeIdsToGroups = this.state.identityNodeIdsToGroups;\n          \n          return (\n            <div>\n            \n              <h3 className=\"title is-3\">\n                {externalIdentityNode.data.identity}\n              </h3>\n              \n              <hr />\n              \n              \n              <div>\n                <h3 className=\"title is-4\">\n                  Groups\n                </h3>\n                \n                <div>\n                  {\n                    !(identityNodeIdsToGroups[externalIdentityNode._id] || []).length ? '':\n                    \n                    <div className=\"tags\">\n                      {\n                        (identityNodeIdsToGroups[externalIdentityNode._id] || []).map(groupNode=>(\n                          <span key={groupNode._id} className=\"tag is-light\">{groupNode.data.name}</span>\n                        ))\n                      }\n                    </div>\n                  }\n                </div>\n                  \n              </div>\n              \n              <hr />\n              \n              {/* Syndication info */}\n              <div>\n                \n                <h3 className=\"title is-4\">\n                  Syndication Permissions\n                </h3>\n                <h3 className=\"subtitle is-6\">\n                  When/What to Syndicate \n                </h3>\n                \n              </div>\n              \n            </div>\n          )\n          \n        }\n        \n        render(){\n          \n          return (\n            <div className=\"container\">\n              <div className=\"columns\">\n                <div className=\"column is-6\">\n                \n                  <br />\n                  \n                  <h2>\n                    <button className=\"button is-info\" onClick={this.handleAddConnection}>\n                      + Connection \n                    </button>\n                    \n                    <hr />\n                    \n                    <div className=\"field has-addons\">\n                      <div className=\"control\">\n                        <button className=\"button\" onClick={this.fetchAll}>\n                          Fetch Latest\n                        </button>\n                      </div>\n                      {\n                        !this.state.fetchingGroups ? '':\n                        <div className=\"control\">\n                          <a className=\"button is-loading\">\n                            &nbsp;\n                          </a>\n                        </div>\n                      }\n                    </div>\n                  </h2>\n                  \n                  <br />\n                  \n                  <div>\n                    {\n                      this.renderConnections()\n                    }\n                  </div>\n                  \n                </div>\n                \n                <div className=\"column is-6\">\n                  {\n                    this.renderConnection()\n                  }\n                </div>\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainConnectionsComponent"
  }
}